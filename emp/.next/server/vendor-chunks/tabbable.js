"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/tabbable";
exports.ids = ["vendor-chunks/tabbable"];
exports.modules = {

/***/ "(ssr)/../node_modules/tabbable/dist/index.esm.js":
/*!**************************************************!*\
  !*** ../node_modules/tabbable/dist/index.esm.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   focusable: () => (/* binding */ focusable),\n/* harmony export */   getTabIndex: () => (/* binding */ getTabIndex),\n/* harmony export */   isFocusable: () => (/* binding */ isFocusable),\n/* harmony export */   isTabbable: () => (/* binding */ isTabbable),\n/* harmony export */   tabbable: () => (/* binding */ tabbable)\n/* harmony export */ });\n/*!\r\n* tabbable 6.2.0\r\n* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE\r\n*/\r\n// NOTE: separate `:not()` selectors has broader browser support than the newer\r\n//  `:not([inert], [inert] *)` (Feb 2023)\r\n// CAREFUL: JSDom does not support `:not([inert] *)` as a selector; using it causes\r\n//  the entire query to fail, resulting in no nodes found, which will break a lot\r\n//  of things... so we have to rely on JS to identify nodes inside an inert container\r\nvar candidateSelectors = ['input:not([inert])', 'select:not([inert])', 'textarea:not([inert])', 'a[href]:not([inert])', 'button:not([inert])', '[tabindex]:not(slot):not([inert])', 'audio[controls]:not([inert])', 'video[controls]:not([inert])', '[contenteditable]:not([contenteditable=\"false\"]):not([inert])', 'details>summary:first-of-type:not([inert])', 'details:not([inert])'];\r\nvar candidateSelector = /* #__PURE__ */candidateSelectors.join(',');\r\nvar NoElement = typeof Element === 'undefined';\r\nvar matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\r\nvar getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {\r\n  var _element$getRootNode;\r\n  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);\r\n} : function (element) {\r\n  return element === null || element === void 0 ? void 0 : element.ownerDocument;\r\n};\r\n\r\n/**\r\n * Determines if a node is inert or in an inert ancestor.\r\n * @param {Element} [node]\r\n * @param {boolean} [lookUp] If true and `node` is not inert, looks up at ancestors to\r\n *  see if any of them are inert. If false, only `node` itself is considered.\r\n * @returns {boolean} True if inert itself or by way of being in an inert ancestor.\r\n *  False if `node` is falsy.\r\n */\r\nvar isInert = function isInert(node, lookUp) {\r\n  var _node$getAttribute;\r\n  if (lookUp === void 0) {\r\n    lookUp = true;\r\n  }\r\n  // CAREFUL: JSDom does not support inert at all, so we can't use the `HTMLElement.inert`\r\n  //  JS API property; we have to check the attribute, which can either be empty or 'true';\r\n  //  if it's `null` (not specified) or 'false', it's an active element\r\n  var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, 'inert');\r\n  var inert = inertAtt === '' || inertAtt === 'true';\r\n\r\n  // NOTE: this could also be handled with `node.matches('[inert], :is([inert] *)')`\r\n  //  if it weren't for `matches()` not being a function on shadow roots; the following\r\n  //  code works for any kind of node\r\n  // CAREFUL: JSDom does not appear to support certain selectors like `:not([inert] *)`\r\n  //  so it likely would not support `:is([inert] *)` either...\r\n  var result = inert || lookUp && node && isInert(node.parentNode); // recursive\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Determines if a node's content is editable.\r\n * @param {Element} [node]\r\n * @returns True if it's content-editable; false if it's not or `node` is falsy.\r\n */\r\nvar isContentEditable = function isContentEditable(node) {\r\n  var _node$getAttribute2;\r\n  // CAREFUL: JSDom does not support the `HTMLElement.isContentEditable` API so we have\r\n  //  to use the attribute directly to check for this, which can either be empty or 'true';\r\n  //  if it's `null` (not specified) or 'false', it's a non-editable element\r\n  var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, 'contenteditable');\r\n  return attValue === '' || attValue === 'true';\r\n};\r\n\r\n/**\r\n * @param {Element} el container to check in\r\n * @param {boolean} includeContainer add container to check\r\n * @param {(node: Element) => boolean} filter filter candidates\r\n * @returns {Element[]}\r\n */\r\nvar getCandidates = function getCandidates(el, includeContainer, filter) {\r\n  // even if `includeContainer=false`, we still have to check it for inertness because\r\n  //  if it's inert, all its children are inert\r\n  if (isInert(el)) {\r\n    return [];\r\n  }\r\n  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));\r\n  if (includeContainer && matches.call(el, candidateSelector)) {\r\n    candidates.unshift(el);\r\n  }\r\n  candidates = candidates.filter(filter);\r\n  return candidates;\r\n};\r\n\r\n/**\r\n * @callback GetShadowRoot\r\n * @param {Element} element to check for shadow root\r\n * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.\r\n */\r\n\r\n/**\r\n * @callback ShadowRootFilter\r\n * @param {Element} shadowHostNode the element which contains shadow content\r\n * @returns {boolean} true if a shadow root could potentially contain valid candidates.\r\n */\r\n\r\n/**\r\n * @typedef {Object} CandidateScope\r\n * @property {Element} scopeParent contains inner candidates\r\n * @property {Element[]} candidates list of candidates found in the scope parent\r\n */\r\n\r\n/**\r\n * @typedef {Object} IterativeOptions\r\n * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;\r\n *  if a function, implies shadow support is enabled and either returns the shadow root of an element\r\n *  or a boolean stating if it has an undisclosed shadow root\r\n * @property {(node: Element) => boolean} filter filter candidates\r\n * @property {boolean} flatten if true then result will flatten any CandidateScope into the returned list\r\n * @property {ShadowRootFilter} shadowRootFilter filter shadow roots;\r\n */\r\n\r\n/**\r\n * @param {Element[]} elements list of element containers to match candidates from\r\n * @param {boolean} includeContainer add container list to check\r\n * @param {IterativeOptions} options\r\n * @returns {Array.<Element|CandidateScope>}\r\n */\r\nvar getCandidatesIteratively = function getCandidatesIteratively(elements, includeContainer, options) {\r\n  var candidates = [];\r\n  var elementsToCheck = Array.from(elements);\r\n  while (elementsToCheck.length) {\r\n    var element = elementsToCheck.shift();\r\n    if (isInert(element, false)) {\r\n      // no need to look up since we're drilling down\r\n      // anything inside this container will also be inert\r\n      continue;\r\n    }\r\n    if (element.tagName === 'SLOT') {\r\n      // add shadow dom slot scope (slot itself cannot be focusable)\r\n      var assigned = element.assignedElements();\r\n      var content = assigned.length ? assigned : element.children;\r\n      var nestedCandidates = getCandidatesIteratively(content, true, options);\r\n      if (options.flatten) {\r\n        candidates.push.apply(candidates, nestedCandidates);\r\n      } else {\r\n        candidates.push({\r\n          scopeParent: element,\r\n          candidates: nestedCandidates\r\n        });\r\n      }\r\n    } else {\r\n      // check candidate element\r\n      var validCandidate = matches.call(element, candidateSelector);\r\n      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {\r\n        candidates.push(element);\r\n      }\r\n\r\n      // iterate over shadow content if possible\r\n      var shadowRoot = element.shadowRoot ||\r\n      // check for an undisclosed shadow\r\n      typeof options.getShadowRoot === 'function' && options.getShadowRoot(element);\r\n\r\n      // no inert look up because we're already drilling down and checking for inertness\r\n      //  on the way down, so all containers to this root node should have already been\r\n      //  vetted as non-inert\r\n      var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));\r\n      if (shadowRoot && validShadowRoot) {\r\n        // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed\r\n        //  shadow exists, so look at light dom children as fallback BUT create a scope for any\r\n        //  child candidates found because they're likely slotted elements (elements that are\r\n        //  children of the web component element (which has the shadow), in the light dom, but\r\n        //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,\r\n        //  _after_ we return from this recursive call\r\n        var _nestedCandidates = getCandidatesIteratively(shadowRoot === true ? element.children : shadowRoot.children, true, options);\r\n        if (options.flatten) {\r\n          candidates.push.apply(candidates, _nestedCandidates);\r\n        } else {\r\n          candidates.push({\r\n            scopeParent: element,\r\n            candidates: _nestedCandidates\r\n          });\r\n        }\r\n      } else {\r\n        // there's not shadow so just dig into the element's (light dom) children\r\n        //  __without__ giving the element special scope treatment\r\n        elementsToCheck.unshift.apply(elementsToCheck, element.children);\r\n      }\r\n    }\r\n  }\r\n  return candidates;\r\n};\r\n\r\n/**\r\n * @private\r\n * Determines if the node has an explicitly specified `tabindex` attribute.\r\n * @param {HTMLElement} node\r\n * @returns {boolean} True if so; false if not.\r\n */\r\nvar hasTabIndex = function hasTabIndex(node) {\r\n  return !isNaN(parseInt(node.getAttribute('tabindex'), 10));\r\n};\r\n\r\n/**\r\n * Determine the tab index of a given node.\r\n * @param {HTMLElement} node\r\n * @returns {number} Tab order (negative, 0, or positive number).\r\n * @throws {Error} If `node` is falsy.\r\n */\r\nvar getTabIndex = function getTabIndex(node) {\r\n  if (!node) {\r\n    throw new Error('No node provided');\r\n  }\r\n  if (node.tabIndex < 0) {\r\n    // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\r\n    // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\r\n    // yet they are still part of the regular tab order; in FF, they get a default\r\n    // `tabIndex` of 0; since Chrome still puts those elements in the regular tab\r\n    // order, consider their tab index to be 0.\r\n    // Also browsers do not return `tabIndex` correctly for contentEditable nodes;\r\n    // so if they don't have a tabindex attribute specifically set, assume it's 0.\r\n    if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {\r\n      return 0;\r\n    }\r\n  }\r\n  return node.tabIndex;\r\n};\r\n\r\n/**\r\n * Determine the tab index of a given node __for sort order purposes__.\r\n * @param {HTMLElement} node\r\n * @param {boolean} [isScope] True for a custom element with shadow root or slot that, by default,\r\n *  has tabIndex -1, but needs to be sorted by document order in order for its content to be\r\n *  inserted into the correct sort position.\r\n * @returns {number} Tab order (negative, 0, or positive number).\r\n */\r\nvar getSortOrderTabIndex = function getSortOrderTabIndex(node, isScope) {\r\n  var tabIndex = getTabIndex(node);\r\n  if (tabIndex < 0 && isScope && !hasTabIndex(node)) {\r\n    return 0;\r\n  }\r\n  return tabIndex;\r\n};\r\nvar sortOrderedTabbables = function sortOrderedTabbables(a, b) {\r\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\r\n};\r\nvar isInput = function isInput(node) {\r\n  return node.tagName === 'INPUT';\r\n};\r\nvar isHiddenInput = function isHiddenInput(node) {\r\n  return isInput(node) && node.type === 'hidden';\r\n};\r\nvar isDetailsWithSummary = function isDetailsWithSummary(node) {\r\n  var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {\r\n    return child.tagName === 'SUMMARY';\r\n  });\r\n  return r;\r\n};\r\nvar getCheckedRadio = function getCheckedRadio(nodes, form) {\r\n  for (var i = 0; i < nodes.length; i++) {\r\n    if (nodes[i].checked && nodes[i].form === form) {\r\n      return nodes[i];\r\n    }\r\n  }\r\n};\r\nvar isTabbableRadio = function isTabbableRadio(node) {\r\n  if (!node.name) {\r\n    return true;\r\n  }\r\n  var radioScope = node.form || getRootNode(node);\r\n  var queryRadios = function queryRadios(name) {\r\n    return radioScope.querySelectorAll('input[type=\"radio\"][name=\"' + name + '\"]');\r\n  };\r\n  var radioSet;\r\n  if (typeof window !== 'undefined' && typeof window.CSS !== 'undefined' && typeof window.CSS.escape === 'function') {\r\n    radioSet = queryRadios(window.CSS.escape(node.name));\r\n  } else {\r\n    try {\r\n      radioSet = queryRadios(node.name);\r\n    } catch (err) {\r\n      // eslint-disable-next-line no-console\r\n      console.error('Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s', err.message);\r\n      return false;\r\n    }\r\n  }\r\n  var checked = getCheckedRadio(radioSet, node.form);\r\n  return !checked || checked === node;\r\n};\r\nvar isRadio = function isRadio(node) {\r\n  return isInput(node) && node.type === 'radio';\r\n};\r\nvar isNonTabbableRadio = function isNonTabbableRadio(node) {\r\n  return isRadio(node) && !isTabbableRadio(node);\r\n};\r\n\r\n// determines if a node is ultimately attached to the window's document\r\nvar isNodeAttached = function isNodeAttached(node) {\r\n  var _nodeRoot;\r\n  // The root node is the shadow root if the node is in a shadow DOM; some document otherwise\r\n  //  (but NOT _the_ document; see second 'If' comment below for more).\r\n  // If rootNode is shadow root, it'll have a host, which is the element to which the shadow\r\n  //  is attached, and the one we need to check if it's in the document or not (because the\r\n  //  shadow, and all nodes it contains, is never considered in the document since shadows\r\n  //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,\r\n  //  is hidden, or is not in the document itself but is detached, it will affect the shadow's\r\n  //  visibility, including all the nodes it contains). The host could be any normal node,\r\n  //  or a custom element (i.e. web component). Either way, that's the one that is considered\r\n  //  part of the document, not the shadow root, nor any of its children (i.e. the node being\r\n  //  tested).\r\n  // To further complicate things, we have to look all the way up until we find a shadow HOST\r\n  //  that is attached (or find none) because the node might be in nested shadows...\r\n  // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the\r\n  //  document (per the docs) and while it's a Document-type object, that document does not\r\n  //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer\r\n  //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,\r\n  //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when\r\n  //  node is actually detached.\r\n  // NOTE: If `nodeRootHost` or `node` happens to be the `document` itself (which is possible\r\n  //  if a tabbable/focusable node was quickly added to the DOM, focused, and then removed\r\n  //  from the DOM as in https://github.com/focus-trap/focus-trap-react/issues/905), then\r\n  //  `ownerDocument` will be `null`, hence the optional chaining on it.\r\n  var nodeRoot = node && getRootNode(node);\r\n  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;\r\n\r\n  // in some cases, a detached node will return itself as the root instead of a document or\r\n  //  shadow root object, in which case, we shouldn't try to look further up the host chain\r\n  var attached = false;\r\n  if (nodeRoot && nodeRoot !== node) {\r\n    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;\r\n    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));\r\n    while (!attached && nodeRootHost) {\r\n      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;\r\n      // since it's not attached and we have a root host, the node MUST be in a nested shadow DOM,\r\n      //  which means we need to get the host's host and check if that parent host is contained\r\n      //  in (i.e. attached to) the document\r\n      nodeRoot = getRootNode(nodeRootHost);\r\n      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;\r\n      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));\r\n    }\r\n  }\r\n  return attached;\r\n};\r\nvar isZeroArea = function isZeroArea(node) {\r\n  var _node$getBoundingClie = node.getBoundingClientRect(),\r\n    width = _node$getBoundingClie.width,\r\n    height = _node$getBoundingClie.height;\r\n  return width === 0 && height === 0;\r\n};\r\nvar isHidden = function isHidden(node, _ref) {\r\n  var displayCheck = _ref.displayCheck,\r\n    getShadowRoot = _ref.getShadowRoot;\r\n  // NOTE: visibility will be `undefined` if node is detached from the document\r\n  //  (see notes about this further down), which means we will consider it visible\r\n  //  (this is legacy behavior from a very long way back)\r\n  // NOTE: we check this regardless of `displayCheck=\"none\"` because this is a\r\n  //  _visibility_ check, not a _display_ check\r\n  if (getComputedStyle(node).visibility === 'hidden') {\r\n    return true;\r\n  }\r\n  var isDirectSummary = matches.call(node, 'details>summary:first-of-type');\r\n  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;\r\n  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {\r\n    return true;\r\n  }\r\n  if (!displayCheck || displayCheck === 'full' || displayCheck === 'legacy-full') {\r\n    if (typeof getShadowRoot === 'function') {\r\n      // figure out if we should consider the node to be in an undisclosed shadow and use the\r\n      //  'non-zero-area' fallback\r\n      var originalNode = node;\r\n      while (node) {\r\n        var parentElement = node.parentElement;\r\n        var rootNode = getRootNode(node);\r\n        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow\r\n        ) {\r\n          // node has an undisclosed shadow which means we can only treat it as a black box, so we\r\n          //  fall back to a non-zero-area test\r\n          return isZeroArea(node);\r\n        } else if (node.assignedSlot) {\r\n          // iterate up slot\r\n          node = node.assignedSlot;\r\n        } else if (!parentElement && rootNode !== node.ownerDocument) {\r\n          // cross shadow boundary\r\n          node = rootNode.host;\r\n        } else {\r\n          // iterate up normal dom\r\n          node = parentElement;\r\n        }\r\n      }\r\n      node = originalNode;\r\n    }\r\n    // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support\r\n    //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or\r\n    //  it might be a falsy value, which means shadow DOM support is disabled\r\n\r\n    // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)\r\n    //  now we can just test to see if it would normally be visible or not, provided it's\r\n    //  attached to the main document.\r\n    // NOTE: We must consider case where node is inside a shadow DOM and given directly to\r\n    //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.\r\n\r\n    if (isNodeAttached(node)) {\r\n      // this works wherever the node is: if there's at least one client rect, it's\r\n      //  somehow displayed; it also covers the CSS 'display: contents' case where the\r\n      //  node itself is hidden in place of its contents; and there's no need to search\r\n      //  up the hierarchy either\r\n      return !node.getClientRects().length;\r\n    }\r\n\r\n    // Else, the node isn't attached to the document, which means the `getClientRects()`\r\n    //  API will __always__ return zero rects (this can happen, for example, if React\r\n    //  is used to render nodes onto a detached tree, as confirmed in this thread:\r\n    //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)\r\n    //\r\n    // It also means that even window.getComputedStyle(node).display will return `undefined`\r\n    //  because styles are only computed for nodes that are in the document.\r\n    //\r\n    // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable\r\n    //  somehow. Though it was never stated officially, anyone who has ever used tabbable\r\n    //  APIs on nodes in detached containers has actually implicitly used tabbable in what\r\n    //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck=\"none\"` mode -- essentially\r\n    //  considering __everything__ to be visible because of the innability to determine styles.\r\n    //\r\n    // v6.0.0: As of this major release, the default 'full' option __no longer treats detached\r\n    //  nodes as visible with the 'none' fallback.__\r\n    if (displayCheck !== 'legacy-full') {\r\n      return true; // hidden\r\n    }\r\n    // else, fallback to 'none' mode and consider the node visible\r\n  } else if (displayCheck === 'non-zero-area') {\r\n    // NOTE: Even though this tests that the node's client rect is non-zero to determine\r\n    //  whether it's displayed, and that a detached node will __always__ have a zero-area\r\n    //  client rect, we don't special-case for whether the node is attached or not. In\r\n    //  this mode, we do want to consider nodes that have a zero area to be hidden at all\r\n    //  times, and that includes attached or not.\r\n    return isZeroArea(node);\r\n  }\r\n\r\n  // visible, as far as we can tell, or per current `displayCheck=none` mode, we assume\r\n  //  it's visible\r\n  return false;\r\n};\r\n\r\n// form fields (nested) inside a disabled fieldset are not focusable/tabbable\r\n//  unless they are in the _first_ <legend> element of the top-most disabled\r\n//  fieldset\r\nvar isDisabledFromFieldset = function isDisabledFromFieldset(node) {\r\n  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {\r\n    var parentNode = node.parentElement;\r\n    // check if `node` is contained in a disabled <fieldset>\r\n    while (parentNode) {\r\n      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {\r\n        // look for the first <legend> among the children of the disabled <fieldset>\r\n        for (var i = 0; i < parentNode.children.length; i++) {\r\n          var child = parentNode.children.item(i);\r\n          // when the first <legend> (in document order) is found\r\n          if (child.tagName === 'LEGEND') {\r\n            // if its parent <fieldset> is not nested in another disabled <fieldset>,\r\n            // return whether `node` is a descendant of its first <legend>\r\n            return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);\r\n          }\r\n        }\r\n        // the disabled <fieldset> containing `node` has no <legend>\r\n        return true;\r\n      }\r\n      parentNode = parentNode.parentElement;\r\n    }\r\n  }\r\n\r\n  // else, node's tabbable/focusable state should not be affected by a fieldset's\r\n  //  enabled/disabled state\r\n  return false;\r\n};\r\nvar isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {\r\n  if (node.disabled ||\r\n  // we must do an inert look up to filter out any elements inside an inert ancestor\r\n  //  because we're limited in the type of selectors we can use in JSDom (see related\r\n  //  note related to `candidateSelectors`)\r\n  isInert(node) || isHiddenInput(node) || isHidden(node, options) ||\r\n  // For a details element with a summary, the summary element gets the focus\r\n  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {\r\n    return false;\r\n  }\r\n  return true;\r\n};\r\nvar isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(options, node) {\r\n  if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {\r\n    return false;\r\n  }\r\n  return true;\r\n};\r\nvar isValidShadowRootTabbable = function isValidShadowRootTabbable(shadowHostNode) {\r\n  var tabIndex = parseInt(shadowHostNode.getAttribute('tabindex'), 10);\r\n  if (isNaN(tabIndex) || tabIndex >= 0) {\r\n    return true;\r\n  }\r\n  // If a custom element has an explicit negative tabindex,\r\n  // browsers will not allow tab targeting said element's children.\r\n  return false;\r\n};\r\n\r\n/**\r\n * @param {Array.<Element|CandidateScope>} candidates\r\n * @returns Element[]\r\n */\r\nvar sortByOrder = function sortByOrder(candidates) {\r\n  var regularTabbables = [];\r\n  var orderedTabbables = [];\r\n  candidates.forEach(function (item, i) {\r\n    var isScope = !!item.scopeParent;\r\n    var element = isScope ? item.scopeParent : item;\r\n    var candidateTabindex = getSortOrderTabIndex(element, isScope);\r\n    var elements = isScope ? sortByOrder(item.candidates) : element;\r\n    if (candidateTabindex === 0) {\r\n      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);\r\n    } else {\r\n      orderedTabbables.push({\r\n        documentOrder: i,\r\n        tabIndex: candidateTabindex,\r\n        item: item,\r\n        isScope: isScope,\r\n        content: elements\r\n      });\r\n    }\r\n  });\r\n  return orderedTabbables.sort(sortOrderedTabbables).reduce(function (acc, sortable) {\r\n    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);\r\n    return acc;\r\n  }, []).concat(regularTabbables);\r\n};\r\nvar tabbable = function tabbable(container, options) {\r\n  options = options || {};\r\n  var candidates;\r\n  if (options.getShadowRoot) {\r\n    candidates = getCandidatesIteratively([container], options.includeContainer, {\r\n      filter: isNodeMatchingSelectorTabbable.bind(null, options),\r\n      flatten: false,\r\n      getShadowRoot: options.getShadowRoot,\r\n      shadowRootFilter: isValidShadowRootTabbable\r\n    });\r\n  } else {\r\n    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));\r\n  }\r\n  return sortByOrder(candidates);\r\n};\r\nvar focusable = function focusable(container, options) {\r\n  options = options || {};\r\n  var candidates;\r\n  if (options.getShadowRoot) {\r\n    candidates = getCandidatesIteratively([container], options.includeContainer, {\r\n      filter: isNodeMatchingSelectorFocusable.bind(null, options),\r\n      flatten: true,\r\n      getShadowRoot: options.getShadowRoot\r\n    });\r\n  } else {\r\n    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));\r\n  }\r\n  return candidates;\r\n};\r\nvar isTabbable = function isTabbable(node, options) {\r\n  options = options || {};\r\n  if (!node) {\r\n    throw new Error('No node provided');\r\n  }\r\n  if (matches.call(node, candidateSelector) === false) {\r\n    return false;\r\n  }\r\n  return isNodeMatchingSelectorTabbable(options, node);\r\n};\r\nvar focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');\r\nvar isFocusable = function isFocusable(node, options) {\r\n  options = options || {};\r\n  if (!node) {\r\n    throw new Error('No node provided');\r\n  }\r\n  if (matches.call(node, focusableCandidateSelector) === false) {\r\n    return false;\r\n  }\r\n  return isNodeMatchingSelectorFocusable(options, node);\r\n};\r\n\r\n\r\n//# sourceMappingURL=index.esm.js.map\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3RhYmJhYmxlL2Rpc3QvaW5kZXguZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLDRCQUE0QjtBQUN2QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsU0FBUztBQUN2QixjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsdUJBQXVCLGlEQUFpRDtBQUN0RjtBQUNBO0FBQ0EsY0FBYyw0QkFBNEI7QUFDMUMsY0FBYyxTQUFT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ZXMiOlsid2VicGFjazovL2VtcGxveWVlLy4uL25vZGVfbW9kdWxlcy90YWJiYWJsZS9kaXN0L2luZGV4LmVzbS5qcz8xYTdlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxyXG4qIHRhYmJhYmxlIDYuMi4wXHJcbiogQGxpY2Vuc2UgTUlULCBodHRwczovL2dpdGh1Yi5jb20vZm9jdXMtdHJhcC90YWJiYWJsZS9ibG9iL21hc3Rlci9MSUNFTlNFXHJcbiovXHJcbi8vIE5PVEU6IHNlcGFyYXRlIGA6bm90KClgIHNlbGVjdG9ycyBoYXMgYnJvYWRlciBicm93c2VyIHN1cHBvcnQgdGhhbiB0aGUgbmV3ZXJcclxuLy8gIGA6bm90KFtpbmVydF0sIFtpbmVydF0gKilgIChGZWIgMjAyMylcclxuLy8gQ0FSRUZVTDogSlNEb20gZG9lcyBub3Qgc3VwcG9ydCBgOm5vdChbaW5lcnRdICopYCBhcyBhIHNlbGVjdG9yOyB1c2luZyBpdCBjYXVzZXNcclxuLy8gIHRoZSBlbnRpcmUgcXVlcnkgdG8gZmFpbCwgcmVzdWx0aW5nIGluIG5vIG5vZGVzIGZvdW5kLCB3aGljaCB3aWxsIGJyZWFrIGEgbG90XHJcbi8vICBvZiB0aGluZ3MuLi4gc28gd2UgaGF2ZSB0byByZWx5IG9uIEpTIHRvIGlkZW50aWZ5IG5vZGVzIGluc2lkZSBhbiBpbmVydCBjb250YWluZXJcclxudmFyIGNhbmRpZGF0ZVNlbGVjdG9ycyA9IFsnaW5wdXQ6bm90KFtpbmVydF0pJywgJ3NlbGVjdDpub3QoW2luZXJ0XSknLCAndGV4dGFyZWE6bm90KFtpbmVydF0pJywgJ2FbaHJlZl06bm90KFtpbmVydF0pJywgJ2J1dHRvbjpub3QoW2luZXJ0XSknLCAnW3RhYmluZGV4XTpub3Qoc2xvdCk6bm90KFtpbmVydF0pJywgJ2F1ZGlvW2NvbnRyb2xzXTpub3QoW2luZXJ0XSknLCAndmlkZW9bY29udHJvbHNdOm5vdChbaW5lcnRdKScsICdbY29udGVudGVkaXRhYmxlXTpub3QoW2NvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCJdKTpub3QoW2luZXJ0XSknLCAnZGV0YWlscz5zdW1tYXJ5OmZpcnN0LW9mLXR5cGU6bm90KFtpbmVydF0pJywgJ2RldGFpbHM6bm90KFtpbmVydF0pJ107XHJcbnZhciBjYW5kaWRhdGVTZWxlY3RvciA9IC8qICNfX1BVUkVfXyAqL2NhbmRpZGF0ZVNlbGVjdG9ycy5qb2luKCcsJyk7XHJcbnZhciBOb0VsZW1lbnQgPSB0eXBlb2YgRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCc7XHJcbnZhciBtYXRjaGVzID0gTm9FbGVtZW50ID8gZnVuY3Rpb24gKCkge30gOiBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvcjtcclxudmFyIGdldFJvb3ROb2RlID0gIU5vRWxlbWVudCAmJiBFbGVtZW50LnByb3RvdHlwZS5nZXRSb290Tm9kZSA/IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgdmFyIF9lbGVtZW50JGdldFJvb3ROb2RlO1xyXG4gIHJldHVybiBlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfZWxlbWVudCRnZXRSb290Tm9kZSA9IGVsZW1lbnQuZ2V0Um9vdE5vZGUpID09PSBudWxsIHx8IF9lbGVtZW50JGdldFJvb3ROb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZWxlbWVudCRnZXRSb290Tm9kZS5jYWxsKGVsZW1lbnQpO1xyXG59IDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICByZXR1cm4gZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XHJcbn07XHJcblxyXG4vKipcclxuICogRGV0ZXJtaW5lcyBpZiBhIG5vZGUgaXMgaW5lcnQgb3IgaW4gYW4gaW5lcnQgYW5jZXN0b3IuXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gW25vZGVdXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2xvb2tVcF0gSWYgdHJ1ZSBhbmQgYG5vZGVgIGlzIG5vdCBpbmVydCwgbG9va3MgdXAgYXQgYW5jZXN0b3JzIHRvXHJcbiAqICBzZWUgaWYgYW55IG9mIHRoZW0gYXJlIGluZXJ0LiBJZiBmYWxzZSwgb25seSBgbm9kZWAgaXRzZWxmIGlzIGNvbnNpZGVyZWQuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIGluZXJ0IGl0c2VsZiBvciBieSB3YXkgb2YgYmVpbmcgaW4gYW4gaW5lcnQgYW5jZXN0b3IuXHJcbiAqICBGYWxzZSBpZiBgbm9kZWAgaXMgZmFsc3kuXHJcbiAqL1xyXG52YXIgaXNJbmVydCA9IGZ1bmN0aW9uIGlzSW5lcnQobm9kZSwgbG9va1VwKSB7XHJcbiAgdmFyIF9ub2RlJGdldEF0dHJpYnV0ZTtcclxuICBpZiAobG9va1VwID09PSB2b2lkIDApIHtcclxuICAgIGxvb2tVcCA9IHRydWU7XHJcbiAgfVxyXG4gIC8vIENBUkVGVUw6IEpTRG9tIGRvZXMgbm90IHN1cHBvcnQgaW5lcnQgYXQgYWxsLCBzbyB3ZSBjYW4ndCB1c2UgdGhlIGBIVE1MRWxlbWVudC5pbmVydGBcclxuICAvLyAgSlMgQVBJIHByb3BlcnR5OyB3ZSBoYXZlIHRvIGNoZWNrIHRoZSBhdHRyaWJ1dGUsIHdoaWNoIGNhbiBlaXRoZXIgYmUgZW1wdHkgb3IgJ3RydWUnO1xyXG4gIC8vICBpZiBpdCdzIGBudWxsYCAobm90IHNwZWNpZmllZCkgb3IgJ2ZhbHNlJywgaXQncyBhbiBhY3RpdmUgZWxlbWVudFxyXG4gIHZhciBpbmVydEF0dCA9IG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9ub2RlJGdldEF0dHJpYnV0ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKSA9PT0gbnVsbCB8fCBfbm9kZSRnZXRBdHRyaWJ1dGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlJGdldEF0dHJpYnV0ZS5jYWxsKG5vZGUsICdpbmVydCcpO1xyXG4gIHZhciBpbmVydCA9IGluZXJ0QXR0ID09PSAnJyB8fCBpbmVydEF0dCA9PT0gJ3RydWUnO1xyXG5cclxuICAvLyBOT1RFOiB0aGlzIGNvdWxkIGFsc28gYmUgaGFuZGxlZCB3aXRoIGBub2RlLm1hdGNoZXMoJ1tpbmVydF0sIDppcyhbaW5lcnRdICopJylgXHJcbiAgLy8gIGlmIGl0IHdlcmVuJ3QgZm9yIGBtYXRjaGVzKClgIG5vdCBiZWluZyBhIGZ1bmN0aW9uIG9uIHNoYWRvdyByb290czsgdGhlIGZvbGxvd2luZ1xyXG4gIC8vICBjb2RlIHdvcmtzIGZvciBhbnkga2luZCBvZiBub2RlXHJcbiAgLy8gQ0FSRUZVTDogSlNEb20gZG9lcyBub3QgYXBwZWFyIHRvIHN1cHBvcnQgY2VydGFpbiBzZWxlY3RvcnMgbGlrZSBgOm5vdChbaW5lcnRdICopYFxyXG4gIC8vICBzbyBpdCBsaWtlbHkgd291bGQgbm90IHN1cHBvcnQgYDppcyhbaW5lcnRdICopYCBlaXRoZXIuLi5cclxuICB2YXIgcmVzdWx0ID0gaW5lcnQgfHwgbG9va1VwICYmIG5vZGUgJiYgaXNJbmVydChub2RlLnBhcmVudE5vZGUpOyAvLyByZWN1cnNpdmVcclxuXHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBEZXRlcm1pbmVzIGlmIGEgbm9kZSdzIGNvbnRlbnQgaXMgZWRpdGFibGUuXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gW25vZGVdXHJcbiAqIEByZXR1cm5zIFRydWUgaWYgaXQncyBjb250ZW50LWVkaXRhYmxlOyBmYWxzZSBpZiBpdCdzIG5vdCBvciBgbm9kZWAgaXMgZmFsc3kuXHJcbiAqL1xyXG52YXIgaXNDb250ZW50RWRpdGFibGUgPSBmdW5jdGlvbiBpc0NvbnRlbnRFZGl0YWJsZShub2RlKSB7XHJcbiAgdmFyIF9ub2RlJGdldEF0dHJpYnV0ZTI7XHJcbiAgLy8gQ0FSRUZVTDogSlNEb20gZG9lcyBub3Qgc3VwcG9ydCB0aGUgYEhUTUxFbGVtZW50LmlzQ29udGVudEVkaXRhYmxlYCBBUEkgc28gd2UgaGF2ZVxyXG4gIC8vICB0byB1c2UgdGhlIGF0dHJpYnV0ZSBkaXJlY3RseSB0byBjaGVjayBmb3IgdGhpcywgd2hpY2ggY2FuIGVpdGhlciBiZSBlbXB0eSBvciAndHJ1ZSc7XHJcbiAgLy8gIGlmIGl0J3MgYG51bGxgIChub3Qgc3BlY2lmaWVkKSBvciAnZmFsc2UnLCBpdCdzIGEgbm9uLWVkaXRhYmxlIGVsZW1lbnRcclxuICB2YXIgYXR0VmFsdWUgPSBub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfbm9kZSRnZXRBdHRyaWJ1dGUyID0gbm9kZS5nZXRBdHRyaWJ1dGUpID09PSBudWxsIHx8IF9ub2RlJGdldEF0dHJpYnV0ZTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlJGdldEF0dHJpYnV0ZTIuY2FsbChub2RlLCAnY29udGVudGVkaXRhYmxlJyk7XHJcbiAgcmV0dXJuIGF0dFZhbHVlID09PSAnJyB8fCBhdHRWYWx1ZSA9PT0gJ3RydWUnO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWwgY29udGFpbmVyIHRvIGNoZWNrIGluXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5jbHVkZUNvbnRhaW5lciBhZGQgY29udGFpbmVyIHRvIGNoZWNrXHJcbiAqIEBwYXJhbSB7KG5vZGU6IEVsZW1lbnQpID0+IGJvb2xlYW59IGZpbHRlciBmaWx0ZXIgY2FuZGlkYXRlc1xyXG4gKiBAcmV0dXJucyB7RWxlbWVudFtdfVxyXG4gKi9cclxudmFyIGdldENhbmRpZGF0ZXMgPSBmdW5jdGlvbiBnZXRDYW5kaWRhdGVzKGVsLCBpbmNsdWRlQ29udGFpbmVyLCBmaWx0ZXIpIHtcclxuICAvLyBldmVuIGlmIGBpbmNsdWRlQ29udGFpbmVyPWZhbHNlYCwgd2Ugc3RpbGwgaGF2ZSB0byBjaGVjayBpdCBmb3IgaW5lcnRuZXNzIGJlY2F1c2VcclxuICAvLyAgaWYgaXQncyBpbmVydCwgYWxsIGl0cyBjaGlsZHJlbiBhcmUgaW5lcnRcclxuICBpZiAoaXNJbmVydChlbCkpIHtcclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcbiAgdmFyIGNhbmRpZGF0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoZWwucXVlcnlTZWxlY3RvckFsbChjYW5kaWRhdGVTZWxlY3RvcikpO1xyXG4gIGlmIChpbmNsdWRlQ29udGFpbmVyICYmIG1hdGNoZXMuY2FsbChlbCwgY2FuZGlkYXRlU2VsZWN0b3IpKSB7XHJcbiAgICBjYW5kaWRhdGVzLnVuc2hpZnQoZWwpO1xyXG4gIH1cclxuICBjYW5kaWRhdGVzID0gY2FuZGlkYXRlcy5maWx0ZXIoZmlsdGVyKTtcclxuICByZXR1cm4gY2FuZGlkYXRlcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAY2FsbGJhY2sgR2V0U2hhZG93Um9vdFxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgdG8gY2hlY2sgZm9yIHNoYWRvdyByb290XHJcbiAqIEByZXR1cm5zIHtTaGFkb3dSb290fGJvb2xlYW59IFNoYWRvd1Jvb3QgaWYgYXZhaWxhYmxlIG9yIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBhIHNoYWRvd1Jvb3QgaXMgYXR0YWNoZWQgYnV0IG5vdCBhdmFpbGFibGUuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBTaGFkb3dSb290RmlsdGVyXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gc2hhZG93SG9zdE5vZGUgdGhlIGVsZW1lbnQgd2hpY2ggY29udGFpbnMgc2hhZG93IGNvbnRlbnRcclxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgYSBzaGFkb3cgcm9vdCBjb3VsZCBwb3RlbnRpYWxseSBjb250YWluIHZhbGlkIGNhbmRpZGF0ZXMuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENhbmRpZGF0ZVNjb3BlXHJcbiAqIEBwcm9wZXJ0eSB7RWxlbWVudH0gc2NvcGVQYXJlbnQgY29udGFpbnMgaW5uZXIgY2FuZGlkYXRlc1xyXG4gKiBAcHJvcGVydHkge0VsZW1lbnRbXX0gY2FuZGlkYXRlcyBsaXN0IG9mIGNhbmRpZGF0ZXMgZm91bmQgaW4gdGhlIHNjb3BlIHBhcmVudFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBJdGVyYXRpdmVPcHRpb25zXHJcbiAqIEBwcm9wZXJ0eSB7R2V0U2hhZG93Um9vdHxib29sZWFufSBnZXRTaGFkb3dSb290IHRydWUgaWYgc2hhZG93IHN1cHBvcnQgaXMgZW5hYmxlZDsgZmFsc3kgaWYgbm90O1xyXG4gKiAgaWYgYSBmdW5jdGlvbiwgaW1wbGllcyBzaGFkb3cgc3VwcG9ydCBpcyBlbmFibGVkIGFuZCBlaXRoZXIgcmV0dXJucyB0aGUgc2hhZG93IHJvb3Qgb2YgYW4gZWxlbWVudFxyXG4gKiAgb3IgYSBib29sZWFuIHN0YXRpbmcgaWYgaXQgaGFzIGFuIHVuZGlzY2xvc2VkIHNoYWRvdyByb290XHJcbiAqIEBwcm9wZXJ0eSB7KG5vZGU6IEVsZW1lbnQpID0+IGJvb2xlYW59IGZpbHRlciBmaWx0ZXIgY2FuZGlkYXRlc1xyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGZsYXR0ZW4gaWYgdHJ1ZSB0aGVuIHJlc3VsdCB3aWxsIGZsYXR0ZW4gYW55IENhbmRpZGF0ZVNjb3BlIGludG8gdGhlIHJldHVybmVkIGxpc3RcclxuICogQHByb3BlcnR5IHtTaGFkb3dSb290RmlsdGVyfSBzaGFkb3dSb290RmlsdGVyIGZpbHRlciBzaGFkb3cgcm9vdHM7XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7RWxlbWVudFtdfSBlbGVtZW50cyBsaXN0IG9mIGVsZW1lbnQgY29udGFpbmVycyB0byBtYXRjaCBjYW5kaWRhdGVzIGZyb21cclxuICogQHBhcmFtIHtib29sZWFufSBpbmNsdWRlQ29udGFpbmVyIGFkZCBjb250YWluZXIgbGlzdCB0byBjaGVja1xyXG4gKiBAcGFyYW0ge0l0ZXJhdGl2ZU9wdGlvbnN9IG9wdGlvbnNcclxuICogQHJldHVybnMge0FycmF5LjxFbGVtZW50fENhbmRpZGF0ZVNjb3BlPn1cclxuICovXHJcbnZhciBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkgPSBmdW5jdGlvbiBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkoZWxlbWVudHMsIGluY2x1ZGVDb250YWluZXIsIG9wdGlvbnMpIHtcclxuICB2YXIgY2FuZGlkYXRlcyA9IFtdO1xyXG4gIHZhciBlbGVtZW50c1RvQ2hlY2sgPSBBcnJheS5mcm9tKGVsZW1lbnRzKTtcclxuICB3aGlsZSAoZWxlbWVudHNUb0NoZWNrLmxlbmd0aCkge1xyXG4gICAgdmFyIGVsZW1lbnQgPSBlbGVtZW50c1RvQ2hlY2suc2hpZnQoKTtcclxuICAgIGlmIChpc0luZXJ0KGVsZW1lbnQsIGZhbHNlKSkge1xyXG4gICAgICAvLyBubyBuZWVkIHRvIGxvb2sgdXAgc2luY2Ugd2UncmUgZHJpbGxpbmcgZG93blxyXG4gICAgICAvLyBhbnl0aGluZyBpbnNpZGUgdGhpcyBjb250YWluZXIgd2lsbCBhbHNvIGJlIGluZXJ0XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKGVsZW1lbnQudGFnTmFtZSA9PT0gJ1NMT1QnKSB7XHJcbiAgICAgIC8vIGFkZCBzaGFkb3cgZG9tIHNsb3Qgc2NvcGUgKHNsb3QgaXRzZWxmIGNhbm5vdCBiZSBmb2N1c2FibGUpXHJcbiAgICAgIHZhciBhc3NpZ25lZCA9IGVsZW1lbnQuYXNzaWduZWRFbGVtZW50cygpO1xyXG4gICAgICB2YXIgY29udGVudCA9IGFzc2lnbmVkLmxlbmd0aCA/IGFzc2lnbmVkIDogZWxlbWVudC5jaGlsZHJlbjtcclxuICAgICAgdmFyIG5lc3RlZENhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkoY29udGVudCwgdHJ1ZSwgb3B0aW9ucyk7XHJcbiAgICAgIGlmIChvcHRpb25zLmZsYXR0ZW4pIHtcclxuICAgICAgICBjYW5kaWRhdGVzLnB1c2guYXBwbHkoY2FuZGlkYXRlcywgbmVzdGVkQ2FuZGlkYXRlcyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY2FuZGlkYXRlcy5wdXNoKHtcclxuICAgICAgICAgIHNjb3BlUGFyZW50OiBlbGVtZW50LFxyXG4gICAgICAgICAgY2FuZGlkYXRlczogbmVzdGVkQ2FuZGlkYXRlc1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBjaGVjayBjYW5kaWRhdGUgZWxlbWVudFxyXG4gICAgICB2YXIgdmFsaWRDYW5kaWRhdGUgPSBtYXRjaGVzLmNhbGwoZWxlbWVudCwgY2FuZGlkYXRlU2VsZWN0b3IpO1xyXG4gICAgICBpZiAodmFsaWRDYW5kaWRhdGUgJiYgb3B0aW9ucy5maWx0ZXIoZWxlbWVudCkgJiYgKGluY2x1ZGVDb250YWluZXIgfHwgIWVsZW1lbnRzLmluY2x1ZGVzKGVsZW1lbnQpKSkge1xyXG4gICAgICAgIGNhbmRpZGF0ZXMucHVzaChlbGVtZW50KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gaXRlcmF0ZSBvdmVyIHNoYWRvdyBjb250ZW50IGlmIHBvc3NpYmxlXHJcbiAgICAgIHZhciBzaGFkb3dSb290ID0gZWxlbWVudC5zaGFkb3dSb290IHx8XHJcbiAgICAgIC8vIGNoZWNrIGZvciBhbiB1bmRpc2Nsb3NlZCBzaGFkb3dcclxuICAgICAgdHlwZW9mIG9wdGlvbnMuZ2V0U2hhZG93Um9vdCA9PT0gJ2Z1bmN0aW9uJyAmJiBvcHRpb25zLmdldFNoYWRvd1Jvb3QoZWxlbWVudCk7XHJcblxyXG4gICAgICAvLyBubyBpbmVydCBsb29rIHVwIGJlY2F1c2Ugd2UncmUgYWxyZWFkeSBkcmlsbGluZyBkb3duIGFuZCBjaGVja2luZyBmb3IgaW5lcnRuZXNzXHJcbiAgICAgIC8vICBvbiB0aGUgd2F5IGRvd24sIHNvIGFsbCBjb250YWluZXJzIHRvIHRoaXMgcm9vdCBub2RlIHNob3VsZCBoYXZlIGFscmVhZHkgYmVlblxyXG4gICAgICAvLyAgdmV0dGVkIGFzIG5vbi1pbmVydFxyXG4gICAgICB2YXIgdmFsaWRTaGFkb3dSb290ID0gIWlzSW5lcnQoc2hhZG93Um9vdCwgZmFsc2UpICYmICghb3B0aW9ucy5zaGFkb3dSb290RmlsdGVyIHx8IG9wdGlvbnMuc2hhZG93Um9vdEZpbHRlcihlbGVtZW50KSk7XHJcbiAgICAgIGlmIChzaGFkb3dSb290ICYmIHZhbGlkU2hhZG93Um9vdCkge1xyXG4gICAgICAgIC8vIGFkZCBzaGFkb3cgZG9tIHNjb3BlIElJRiBhIHNoYWRvdyByb290IG5vZGUgd2FzIGdpdmVuOyBvdGhlcndpc2UsIGFuIHVuZGlzY2xvc2VkXHJcbiAgICAgICAgLy8gIHNoYWRvdyBleGlzdHMsIHNvIGxvb2sgYXQgbGlnaHQgZG9tIGNoaWxkcmVuIGFzIGZhbGxiYWNrIEJVVCBjcmVhdGUgYSBzY29wZSBmb3IgYW55XHJcbiAgICAgICAgLy8gIGNoaWxkIGNhbmRpZGF0ZXMgZm91bmQgYmVjYXVzZSB0aGV5J3JlIGxpa2VseSBzbG90dGVkIGVsZW1lbnRzIChlbGVtZW50cyB0aGF0IGFyZVxyXG4gICAgICAgIC8vICBjaGlsZHJlbiBvZiB0aGUgd2ViIGNvbXBvbmVudCBlbGVtZW50ICh3aGljaCBoYXMgdGhlIHNoYWRvdyksIGluIHRoZSBsaWdodCBkb20sIGJ1dFxyXG4gICAgICAgIC8vICBzbG90dGVkIHNvbWV3aGVyZSBfaW5zaWRlXyB0aGUgdW5kaXNjbG9zZWQgc2hhZG93KSAtLSB0aGUgc2NvcGUgaXMgY3JlYXRlZCBiZWxvdyxcclxuICAgICAgICAvLyAgX2FmdGVyXyB3ZSByZXR1cm4gZnJvbSB0aGlzIHJlY3Vyc2l2ZSBjYWxsXHJcbiAgICAgICAgdmFyIF9uZXN0ZWRDYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlc0l0ZXJhdGl2ZWx5KHNoYWRvd1Jvb3QgPT09IHRydWUgPyBlbGVtZW50LmNoaWxkcmVuIDogc2hhZG93Um9vdC5jaGlsZHJlbiwgdHJ1ZSwgb3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuZmxhdHRlbikge1xyXG4gICAgICAgICAgY2FuZGlkYXRlcy5wdXNoLmFwcGx5KGNhbmRpZGF0ZXMsIF9uZXN0ZWRDYW5kaWRhdGVzKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY2FuZGlkYXRlcy5wdXNoKHtcclxuICAgICAgICAgICAgc2NvcGVQYXJlbnQ6IGVsZW1lbnQsXHJcbiAgICAgICAgICAgIGNhbmRpZGF0ZXM6IF9uZXN0ZWRDYW5kaWRhdGVzXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gdGhlcmUncyBub3Qgc2hhZG93IHNvIGp1c3QgZGlnIGludG8gdGhlIGVsZW1lbnQncyAobGlnaHQgZG9tKSBjaGlsZHJlblxyXG4gICAgICAgIC8vICBfX3dpdGhvdXRfXyBnaXZpbmcgdGhlIGVsZW1lbnQgc3BlY2lhbCBzY29wZSB0cmVhdG1lbnRcclxuICAgICAgICBlbGVtZW50c1RvQ2hlY2sudW5zaGlmdC5hcHBseShlbGVtZW50c1RvQ2hlY2ssIGVsZW1lbnQuY2hpbGRyZW4pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBjYW5kaWRhdGVzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIERldGVybWluZXMgaWYgdGhlIG5vZGUgaGFzIGFuIGV4cGxpY2l0bHkgc3BlY2lmaWVkIGB0YWJpbmRleGAgYXR0cmlidXRlLlxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHNvOyBmYWxzZSBpZiBub3QuXHJcbiAqL1xyXG52YXIgaGFzVGFiSW5kZXggPSBmdW5jdGlvbiBoYXNUYWJJbmRleChub2RlKSB7XHJcbiAgcmV0dXJuICFpc05hTihwYXJzZUludChub2RlLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSwgMTApKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBEZXRlcm1pbmUgdGhlIHRhYiBpbmRleCBvZiBhIGdpdmVuIG5vZGUuXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcclxuICogQHJldHVybnMge251bWJlcn0gVGFiIG9yZGVyIChuZWdhdGl2ZSwgMCwgb3IgcG9zaXRpdmUgbnVtYmVyKS5cclxuICogQHRocm93cyB7RXJyb3J9IElmIGBub2RlYCBpcyBmYWxzeS5cclxuICovXHJcbnZhciBnZXRUYWJJbmRleCA9IGZ1bmN0aW9uIGdldFRhYkluZGV4KG5vZGUpIHtcclxuICBpZiAoIW5vZGUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignTm8gbm9kZSBwcm92aWRlZCcpO1xyXG4gIH1cclxuICBpZiAobm9kZS50YWJJbmRleCA8IDApIHtcclxuICAgIC8vIGluIENocm9tZSwgPGRldGFpbHMvPiwgPGF1ZGlvIGNvbnRyb2xzLz4gYW5kIDx2aWRlbyBjb250cm9scy8+IGVsZW1lbnRzIGdldCBhIGRlZmF1bHRcclxuICAgIC8vIGB0YWJJbmRleGAgb2YgLTEgd2hlbiB0aGUgJ3RhYmluZGV4JyBhdHRyaWJ1dGUgaXNuJ3Qgc3BlY2lmaWVkIGluIHRoZSBET00sXHJcbiAgICAvLyB5ZXQgdGhleSBhcmUgc3RpbGwgcGFydCBvZiB0aGUgcmVndWxhciB0YWIgb3JkZXI7IGluIEZGLCB0aGV5IGdldCBhIGRlZmF1bHRcclxuICAgIC8vIGB0YWJJbmRleGAgb2YgMDsgc2luY2UgQ2hyb21lIHN0aWxsIHB1dHMgdGhvc2UgZWxlbWVudHMgaW4gdGhlIHJlZ3VsYXIgdGFiXHJcbiAgICAvLyBvcmRlciwgY29uc2lkZXIgdGhlaXIgdGFiIGluZGV4IHRvIGJlIDAuXHJcbiAgICAvLyBBbHNvIGJyb3dzZXJzIGRvIG5vdCByZXR1cm4gYHRhYkluZGV4YCBjb3JyZWN0bHkgZm9yIGNvbnRlbnRFZGl0YWJsZSBub2RlcztcclxuICAgIC8vIHNvIGlmIHRoZXkgZG9uJ3QgaGF2ZSBhIHRhYmluZGV4IGF0dHJpYnV0ZSBzcGVjaWZpY2FsbHkgc2V0LCBhc3N1bWUgaXQncyAwLlxyXG4gICAgaWYgKCgvXihBVURJT3xWSURFT3xERVRBSUxTKSQvLnRlc3Qobm9kZS50YWdOYW1lKSB8fCBpc0NvbnRlbnRFZGl0YWJsZShub2RlKSkgJiYgIWhhc1RhYkluZGV4KG5vZGUpKSB7XHJcbiAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gbm9kZS50YWJJbmRleDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBEZXRlcm1pbmUgdGhlIHRhYiBpbmRleCBvZiBhIGdpdmVuIG5vZGUgX19mb3Igc29ydCBvcmRlciBwdXJwb3Nlc19fLlxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU2NvcGVdIFRydWUgZm9yIGEgY3VzdG9tIGVsZW1lbnQgd2l0aCBzaGFkb3cgcm9vdCBvciBzbG90IHRoYXQsIGJ5IGRlZmF1bHQsXHJcbiAqICBoYXMgdGFiSW5kZXggLTEsIGJ1dCBuZWVkcyB0byBiZSBzb3J0ZWQgYnkgZG9jdW1lbnQgb3JkZXIgaW4gb3JkZXIgZm9yIGl0cyBjb250ZW50IHRvIGJlXHJcbiAqICBpbnNlcnRlZCBpbnRvIHRoZSBjb3JyZWN0IHNvcnQgcG9zaXRpb24uXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRhYiBvcmRlciAobmVnYXRpdmUsIDAsIG9yIHBvc2l0aXZlIG51bWJlcikuXHJcbiAqL1xyXG52YXIgZ2V0U29ydE9yZGVyVGFiSW5kZXggPSBmdW5jdGlvbiBnZXRTb3J0T3JkZXJUYWJJbmRleChub2RlLCBpc1Njb3BlKSB7XHJcbiAgdmFyIHRhYkluZGV4ID0gZ2V0VGFiSW5kZXgobm9kZSk7XHJcbiAgaWYgKHRhYkluZGV4IDwgMCAmJiBpc1Njb3BlICYmICFoYXNUYWJJbmRleChub2RlKSkge1xyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG4gIHJldHVybiB0YWJJbmRleDtcclxufTtcclxudmFyIHNvcnRPcmRlcmVkVGFiYmFibGVzID0gZnVuY3Rpb24gc29ydE9yZGVyZWRUYWJiYWJsZXMoYSwgYikge1xyXG4gIHJldHVybiBhLnRhYkluZGV4ID09PSBiLnRhYkluZGV4ID8gYS5kb2N1bWVudE9yZGVyIC0gYi5kb2N1bWVudE9yZGVyIDogYS50YWJJbmRleCAtIGIudGFiSW5kZXg7XHJcbn07XHJcbnZhciBpc0lucHV0ID0gZnVuY3Rpb24gaXNJbnB1dChub2RlKSB7XHJcbiAgcmV0dXJuIG5vZGUudGFnTmFtZSA9PT0gJ0lOUFVUJztcclxufTtcclxudmFyIGlzSGlkZGVuSW5wdXQgPSBmdW5jdGlvbiBpc0hpZGRlbklucHV0KG5vZGUpIHtcclxuICByZXR1cm4gaXNJbnB1dChub2RlKSAmJiBub2RlLnR5cGUgPT09ICdoaWRkZW4nO1xyXG59O1xyXG52YXIgaXNEZXRhaWxzV2l0aFN1bW1hcnkgPSBmdW5jdGlvbiBpc0RldGFpbHNXaXRoU3VtbWFyeShub2RlKSB7XHJcbiAgdmFyIHIgPSBub2RlLnRhZ05hbWUgPT09ICdERVRBSUxTJyAmJiBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkobm9kZS5jaGlsZHJlbikuc29tZShmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgIHJldHVybiBjaGlsZC50YWdOYW1lID09PSAnU1VNTUFSWSc7XHJcbiAgfSk7XHJcbiAgcmV0dXJuIHI7XHJcbn07XHJcbnZhciBnZXRDaGVja2VkUmFkaW8gPSBmdW5jdGlvbiBnZXRDaGVja2VkUmFkaW8obm9kZXMsIGZvcm0pIHtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAobm9kZXNbaV0uY2hlY2tlZCAmJiBub2Rlc1tpXS5mb3JtID09PSBmb3JtKSB7XHJcbiAgICAgIHJldHVybiBub2Rlc1tpXTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcbnZhciBpc1RhYmJhYmxlUmFkaW8gPSBmdW5jdGlvbiBpc1RhYmJhYmxlUmFkaW8obm9kZSkge1xyXG4gIGlmICghbm9kZS5uYW1lKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgdmFyIHJhZGlvU2NvcGUgPSBub2RlLmZvcm0gfHwgZ2V0Um9vdE5vZGUobm9kZSk7XHJcbiAgdmFyIHF1ZXJ5UmFkaW9zID0gZnVuY3Rpb24gcXVlcnlSYWRpb3MobmFtZSkge1xyXG4gICAgcmV0dXJuIHJhZGlvU2NvcGUucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbdHlwZT1cInJhZGlvXCJdW25hbWU9XCInICsgbmFtZSArICdcIl0nKTtcclxuICB9O1xyXG4gIHZhciByYWRpb1NldDtcclxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5DU1MgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuQ1NTLmVzY2FwZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgcmFkaW9TZXQgPSBxdWVyeVJhZGlvcyh3aW5kb3cuQ1NTLmVzY2FwZShub2RlLm5hbWUpKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdHJ5IHtcclxuICAgICAgcmFkaW9TZXQgPSBxdWVyeVJhZGlvcyhub2RlLm5hbWUpO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0xvb2tzIGxpa2UgeW91IGhhdmUgYSByYWRpbyBidXR0b24gd2l0aCBhIG5hbWUgYXR0cmlidXRlIGNvbnRhaW5pbmcgaW52YWxpZCBDU1Mgc2VsZWN0b3IgY2hhcmFjdGVycyBhbmQgbmVlZCB0aGUgQ1NTLmVzY2FwZSBwb2x5ZmlsbDogJXMnLCBlcnIubWVzc2FnZSk7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcbiAgdmFyIGNoZWNrZWQgPSBnZXRDaGVja2VkUmFkaW8ocmFkaW9TZXQsIG5vZGUuZm9ybSk7XHJcbiAgcmV0dXJuICFjaGVja2VkIHx8IGNoZWNrZWQgPT09IG5vZGU7XHJcbn07XHJcbnZhciBpc1JhZGlvID0gZnVuY3Rpb24gaXNSYWRpbyhub2RlKSB7XHJcbiAgcmV0dXJuIGlzSW5wdXQobm9kZSkgJiYgbm9kZS50eXBlID09PSAncmFkaW8nO1xyXG59O1xyXG52YXIgaXNOb25UYWJiYWJsZVJhZGlvID0gZnVuY3Rpb24gaXNOb25UYWJiYWJsZVJhZGlvKG5vZGUpIHtcclxuICByZXR1cm4gaXNSYWRpbyhub2RlKSAmJiAhaXNUYWJiYWJsZVJhZGlvKG5vZGUpO1xyXG59O1xyXG5cclxuLy8gZGV0ZXJtaW5lcyBpZiBhIG5vZGUgaXMgdWx0aW1hdGVseSBhdHRhY2hlZCB0byB0aGUgd2luZG93J3MgZG9jdW1lbnRcclxudmFyIGlzTm9kZUF0dGFjaGVkID0gZnVuY3Rpb24gaXNOb2RlQXR0YWNoZWQobm9kZSkge1xyXG4gIHZhciBfbm9kZVJvb3Q7XHJcbiAgLy8gVGhlIHJvb3Qgbm9kZSBpcyB0aGUgc2hhZG93IHJvb3QgaWYgdGhlIG5vZGUgaXMgaW4gYSBzaGFkb3cgRE9NOyBzb21lIGRvY3VtZW50IG90aGVyd2lzZVxyXG4gIC8vICAoYnV0IE5PVCBfdGhlXyBkb2N1bWVudDsgc2VlIHNlY29uZCAnSWYnIGNvbW1lbnQgYmVsb3cgZm9yIG1vcmUpLlxyXG4gIC8vIElmIHJvb3ROb2RlIGlzIHNoYWRvdyByb290LCBpdCdsbCBoYXZlIGEgaG9zdCwgd2hpY2ggaXMgdGhlIGVsZW1lbnQgdG8gd2hpY2ggdGhlIHNoYWRvd1xyXG4gIC8vICBpcyBhdHRhY2hlZCwgYW5kIHRoZSBvbmUgd2UgbmVlZCB0byBjaGVjayBpZiBpdCdzIGluIHRoZSBkb2N1bWVudCBvciBub3QgKGJlY2F1c2UgdGhlXHJcbiAgLy8gIHNoYWRvdywgYW5kIGFsbCBub2RlcyBpdCBjb250YWlucywgaXMgbmV2ZXIgY29uc2lkZXJlZCBpbiB0aGUgZG9jdW1lbnQgc2luY2Ugc2hhZG93c1xyXG4gIC8vICBiZWhhdmUgbGlrZSBzZWxmLWNvbnRhaW5lZCBET01zOyBidXQgaWYgdGhlIHNoYWRvdydzIEhPU1QsIHdoaWNoIGlzIHBhcnQgb2YgdGhlIGRvY3VtZW50LFxyXG4gIC8vICBpcyBoaWRkZW4sIG9yIGlzIG5vdCBpbiB0aGUgZG9jdW1lbnQgaXRzZWxmIGJ1dCBpcyBkZXRhY2hlZCwgaXQgd2lsbCBhZmZlY3QgdGhlIHNoYWRvdydzXHJcbiAgLy8gIHZpc2liaWxpdHksIGluY2x1ZGluZyBhbGwgdGhlIG5vZGVzIGl0IGNvbnRhaW5zKS4gVGhlIGhvc3QgY291bGQgYmUgYW55IG5vcm1hbCBub2RlLFxyXG4gIC8vICBvciBhIGN1c3RvbSBlbGVtZW50IChpLmUuIHdlYiBjb21wb25lbnQpLiBFaXRoZXIgd2F5LCB0aGF0J3MgdGhlIG9uZSB0aGF0IGlzIGNvbnNpZGVyZWRcclxuICAvLyAgcGFydCBvZiB0aGUgZG9jdW1lbnQsIG5vdCB0aGUgc2hhZG93IHJvb3QsIG5vciBhbnkgb2YgaXRzIGNoaWxkcmVuIChpLmUuIHRoZSBub2RlIGJlaW5nXHJcbiAgLy8gIHRlc3RlZCkuXHJcbiAgLy8gVG8gZnVydGhlciBjb21wbGljYXRlIHRoaW5ncywgd2UgaGF2ZSB0byBsb29rIGFsbCB0aGUgd2F5IHVwIHVudGlsIHdlIGZpbmQgYSBzaGFkb3cgSE9TVFxyXG4gIC8vICB0aGF0IGlzIGF0dGFjaGVkIChvciBmaW5kIG5vbmUpIGJlY2F1c2UgdGhlIG5vZGUgbWlnaHQgYmUgaW4gbmVzdGVkIHNoYWRvd3MuLi5cclxuICAvLyBJZiByb290Tm9kZSBpcyBub3QgYSBzaGFkb3cgcm9vdCwgaXQgd29uJ3QgaGF2ZSBhIGhvc3QsIGFuZCBzbyByb290Tm9kZSBzaG91bGQgYmUgdGhlXHJcbiAgLy8gIGRvY3VtZW50IChwZXIgdGhlIGRvY3MpIGFuZCB3aGlsZSBpdCdzIGEgRG9jdW1lbnQtdHlwZSBvYmplY3QsIHRoYXQgZG9jdW1lbnQgZG9lcyBub3RcclxuICAvLyAgYXBwZWFyIHRvIGJlIHRoZSBzYW1lIGFzIHRoZSBub2RlJ3MgYG93bmVyRG9jdW1lbnRgIGZvciBzb21lIHJlYXNvbiwgc28gaXQncyBzYWZlclxyXG4gIC8vICB0byBpZ25vcmUgdGhlIHJvb3ROb2RlIGF0IHRoaXMgcG9pbnQsIGFuZCB1c2UgYG5vZGUub3duZXJEb2N1bWVudGAuIE90aGVyd2lzZSxcclxuICAvLyAgdXNpbmcgYHJvb3ROb2RlLmNvbnRhaW5zKG5vZGUpYCB3aWxsIF9hbHdheXNfIGJlIHRydWUgd2UnbGwgZ2V0IGZhbHNlLXBvc2l0aXZlcyB3aGVuXHJcbiAgLy8gIG5vZGUgaXMgYWN0dWFsbHkgZGV0YWNoZWQuXHJcbiAgLy8gTk9URTogSWYgYG5vZGVSb290SG9zdGAgb3IgYG5vZGVgIGhhcHBlbnMgdG8gYmUgdGhlIGBkb2N1bWVudGAgaXRzZWxmICh3aGljaCBpcyBwb3NzaWJsZVxyXG4gIC8vICBpZiBhIHRhYmJhYmxlL2ZvY3VzYWJsZSBub2RlIHdhcyBxdWlja2x5IGFkZGVkIHRvIHRoZSBET00sIGZvY3VzZWQsIGFuZCB0aGVuIHJlbW92ZWRcclxuICAvLyAgZnJvbSB0aGUgRE9NIGFzIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mb2N1cy10cmFwL2ZvY3VzLXRyYXAtcmVhY3QvaXNzdWVzLzkwNSksIHRoZW5cclxuICAvLyAgYG93bmVyRG9jdW1lbnRgIHdpbGwgYmUgYG51bGxgLCBoZW5jZSB0aGUgb3B0aW9uYWwgY2hhaW5pbmcgb24gaXQuXHJcbiAgdmFyIG5vZGVSb290ID0gbm9kZSAmJiBnZXRSb290Tm9kZShub2RlKTtcclxuICB2YXIgbm9kZVJvb3RIb3N0ID0gKF9ub2RlUm9vdCA9IG5vZGVSb290KSA9PT0gbnVsbCB8fCBfbm9kZVJvb3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlUm9vdC5ob3N0O1xyXG5cclxuICAvLyBpbiBzb21lIGNhc2VzLCBhIGRldGFjaGVkIG5vZGUgd2lsbCByZXR1cm4gaXRzZWxmIGFzIHRoZSByb290IGluc3RlYWQgb2YgYSBkb2N1bWVudCBvclxyXG4gIC8vICBzaGFkb3cgcm9vdCBvYmplY3QsIGluIHdoaWNoIGNhc2UsIHdlIHNob3VsZG4ndCB0cnkgdG8gbG9vayBmdXJ0aGVyIHVwIHRoZSBob3N0IGNoYWluXHJcbiAgdmFyIGF0dGFjaGVkID0gZmFsc2U7XHJcbiAgaWYgKG5vZGVSb290ICYmIG5vZGVSb290ICE9PSBub2RlKSB7XHJcbiAgICB2YXIgX25vZGVSb290SG9zdCwgX25vZGVSb290SG9zdCRvd25lckRvLCBfbm9kZSRvd25lckRvY3VtZW50O1xyXG4gICAgYXR0YWNoZWQgPSAhISgoX25vZGVSb290SG9zdCA9IG5vZGVSb290SG9zdCkgIT09IG51bGwgJiYgX25vZGVSb290SG9zdCAhPT0gdm9pZCAwICYmIChfbm9kZVJvb3RIb3N0JG93bmVyRG8gPSBfbm9kZVJvb3RIb3N0Lm93bmVyRG9jdW1lbnQpICE9PSBudWxsICYmIF9ub2RlUm9vdEhvc3Qkb3duZXJEbyAhPT0gdm9pZCAwICYmIF9ub2RlUm9vdEhvc3Qkb3duZXJEby5jb250YWlucyhub2RlUm9vdEhvc3QpIHx8IG5vZGUgIT09IG51bGwgJiYgbm9kZSAhPT0gdm9pZCAwICYmIChfbm9kZSRvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50KSAhPT0gbnVsbCAmJiBfbm9kZSRvd25lckRvY3VtZW50ICE9PSB2b2lkIDAgJiYgX25vZGUkb3duZXJEb2N1bWVudC5jb250YWlucyhub2RlKSk7XHJcbiAgICB3aGlsZSAoIWF0dGFjaGVkICYmIG5vZGVSb290SG9zdCkge1xyXG4gICAgICB2YXIgX25vZGVSb290MiwgX25vZGVSb290SG9zdDIsIF9ub2RlUm9vdEhvc3QyJG93bmVyRDtcclxuICAgICAgLy8gc2luY2UgaXQncyBub3QgYXR0YWNoZWQgYW5kIHdlIGhhdmUgYSByb290IGhvc3QsIHRoZSBub2RlIE1VU1QgYmUgaW4gYSBuZXN0ZWQgc2hhZG93IERPTSxcclxuICAgICAgLy8gIHdoaWNoIG1lYW5zIHdlIG5lZWQgdG8gZ2V0IHRoZSBob3N0J3MgaG9zdCBhbmQgY2hlY2sgaWYgdGhhdCBwYXJlbnQgaG9zdCBpcyBjb250YWluZWRcclxuICAgICAgLy8gIGluIChpLmUuIGF0dGFjaGVkIHRvKSB0aGUgZG9jdW1lbnRcclxuICAgICAgbm9kZVJvb3QgPSBnZXRSb290Tm9kZShub2RlUm9vdEhvc3QpO1xyXG4gICAgICBub2RlUm9vdEhvc3QgPSAoX25vZGVSb290MiA9IG5vZGVSb290KSA9PT0gbnVsbCB8fCBfbm9kZVJvb3QyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZVJvb3QyLmhvc3Q7XHJcbiAgICAgIGF0dGFjaGVkID0gISEoKF9ub2RlUm9vdEhvc3QyID0gbm9kZVJvb3RIb3N0KSAhPT0gbnVsbCAmJiBfbm9kZVJvb3RIb3N0MiAhPT0gdm9pZCAwICYmIChfbm9kZVJvb3RIb3N0MiRvd25lckQgPSBfbm9kZVJvb3RIb3N0Mi5vd25lckRvY3VtZW50KSAhPT0gbnVsbCAmJiBfbm9kZVJvb3RIb3N0MiRvd25lckQgIT09IHZvaWQgMCAmJiBfbm9kZVJvb3RIb3N0MiRvd25lckQuY29udGFpbnMobm9kZVJvb3RIb3N0KSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBhdHRhY2hlZDtcclxufTtcclxudmFyIGlzWmVyb0FyZWEgPSBmdW5jdGlvbiBpc1plcm9BcmVhKG5vZGUpIHtcclxuICB2YXIgX25vZGUkZ2V0Qm91bmRpbmdDbGllID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcclxuICAgIHdpZHRoID0gX25vZGUkZ2V0Qm91bmRpbmdDbGllLndpZHRoLFxyXG4gICAgaGVpZ2h0ID0gX25vZGUkZ2V0Qm91bmRpbmdDbGllLmhlaWdodDtcclxuICByZXR1cm4gd2lkdGggPT09IDAgJiYgaGVpZ2h0ID09PSAwO1xyXG59O1xyXG52YXIgaXNIaWRkZW4gPSBmdW5jdGlvbiBpc0hpZGRlbihub2RlLCBfcmVmKSB7XHJcbiAgdmFyIGRpc3BsYXlDaGVjayA9IF9yZWYuZGlzcGxheUNoZWNrLFxyXG4gICAgZ2V0U2hhZG93Um9vdCA9IF9yZWYuZ2V0U2hhZG93Um9vdDtcclxuICAvLyBOT1RFOiB2aXNpYmlsaXR5IHdpbGwgYmUgYHVuZGVmaW5lZGAgaWYgbm9kZSBpcyBkZXRhY2hlZCBmcm9tIHRoZSBkb2N1bWVudFxyXG4gIC8vICAoc2VlIG5vdGVzIGFib3V0IHRoaXMgZnVydGhlciBkb3duKSwgd2hpY2ggbWVhbnMgd2Ugd2lsbCBjb25zaWRlciBpdCB2aXNpYmxlXHJcbiAgLy8gICh0aGlzIGlzIGxlZ2FjeSBiZWhhdmlvciBmcm9tIGEgdmVyeSBsb25nIHdheSBiYWNrKVxyXG4gIC8vIE5PVEU6IHdlIGNoZWNrIHRoaXMgcmVnYXJkbGVzcyBvZiBgZGlzcGxheUNoZWNrPVwibm9uZVwiYCBiZWNhdXNlIHRoaXMgaXMgYVxyXG4gIC8vICBfdmlzaWJpbGl0eV8gY2hlY2ssIG5vdCBhIF9kaXNwbGF5XyBjaGVja1xyXG4gIGlmIChnZXRDb21wdXRlZFN0eWxlKG5vZGUpLnZpc2liaWxpdHkgPT09ICdoaWRkZW4nKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgdmFyIGlzRGlyZWN0U3VtbWFyeSA9IG1hdGNoZXMuY2FsbChub2RlLCAnZGV0YWlscz5zdW1tYXJ5OmZpcnN0LW9mLXR5cGUnKTtcclxuICB2YXIgbm9kZVVuZGVyRGV0YWlscyA9IGlzRGlyZWN0U3VtbWFyeSA/IG5vZGUucGFyZW50RWxlbWVudCA6IG5vZGU7XHJcbiAgaWYgKG1hdGNoZXMuY2FsbChub2RlVW5kZXJEZXRhaWxzLCAnZGV0YWlsczpub3QoW29wZW5dKSAqJykpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICBpZiAoIWRpc3BsYXlDaGVjayB8fCBkaXNwbGF5Q2hlY2sgPT09ICdmdWxsJyB8fCBkaXNwbGF5Q2hlY2sgPT09ICdsZWdhY3ktZnVsbCcpIHtcclxuICAgIGlmICh0eXBlb2YgZ2V0U2hhZG93Um9vdCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAvLyBmaWd1cmUgb3V0IGlmIHdlIHNob3VsZCBjb25zaWRlciB0aGUgbm9kZSB0byBiZSBpbiBhbiB1bmRpc2Nsb3NlZCBzaGFkb3cgYW5kIHVzZSB0aGVcclxuICAgICAgLy8gICdub24temVyby1hcmVhJyBmYWxsYmFja1xyXG4gICAgICB2YXIgb3JpZ2luYWxOb2RlID0gbm9kZTtcclxuICAgICAgd2hpbGUgKG5vZGUpIHtcclxuICAgICAgICB2YXIgcGFyZW50RWxlbWVudCA9IG5vZGUucGFyZW50RWxlbWVudDtcclxuICAgICAgICB2YXIgcm9vdE5vZGUgPSBnZXRSb290Tm9kZShub2RlKTtcclxuICAgICAgICBpZiAocGFyZW50RWxlbWVudCAmJiAhcGFyZW50RWxlbWVudC5zaGFkb3dSb290ICYmIGdldFNoYWRvd1Jvb3QocGFyZW50RWxlbWVudCkgPT09IHRydWUgLy8gY2hlY2sgaWYgdGhlcmUncyBhbiB1bmRpc2Nsb3NlZCBzaGFkb3dcclxuICAgICAgICApIHtcclxuICAgICAgICAgIC8vIG5vZGUgaGFzIGFuIHVuZGlzY2xvc2VkIHNoYWRvdyB3aGljaCBtZWFucyB3ZSBjYW4gb25seSB0cmVhdCBpdCBhcyBhIGJsYWNrIGJveCwgc28gd2VcclxuICAgICAgICAgIC8vICBmYWxsIGJhY2sgdG8gYSBub24temVyby1hcmVhIHRlc3RcclxuICAgICAgICAgIHJldHVybiBpc1plcm9BcmVhKG5vZGUpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5hc3NpZ25lZFNsb3QpIHtcclxuICAgICAgICAgIC8vIGl0ZXJhdGUgdXAgc2xvdFxyXG4gICAgICAgICAgbm9kZSA9IG5vZGUuYXNzaWduZWRTbG90O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIXBhcmVudEVsZW1lbnQgJiYgcm9vdE5vZGUgIT09IG5vZGUub3duZXJEb2N1bWVudCkge1xyXG4gICAgICAgICAgLy8gY3Jvc3Mgc2hhZG93IGJvdW5kYXJ5XHJcbiAgICAgICAgICBub2RlID0gcm9vdE5vZGUuaG9zdDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gaXRlcmF0ZSB1cCBub3JtYWwgZG9tXHJcbiAgICAgICAgICBub2RlID0gcGFyZW50RWxlbWVudDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgbm9kZSA9IG9yaWdpbmFsTm9kZTtcclxuICAgIH1cclxuICAgIC8vIGVsc2UsIGBnZXRTaGFkb3dSb290YCBtaWdodCBiZSB0cnVlLCBidXQgYWxsIHRoYXQgZG9lcyBpcyBlbmFibGUgc2hhZG93IERPTSBzdXBwb3J0XHJcbiAgICAvLyAgKGkuZS4gaXQgZG9lcyBub3QgYWxzbyBwcmVzdW1lIHRoYXQgYWxsIG5vZGVzIG1pZ2h0IGhhdmUgdW5kaXNjbG9zZWQgc2hhZG93cyk7IG9yXHJcbiAgICAvLyAgaXQgbWlnaHQgYmUgYSBmYWxzeSB2YWx1ZSwgd2hpY2ggbWVhbnMgc2hhZG93IERPTSBzdXBwb3J0IGlzIGRpc2FibGVkXHJcblxyXG4gICAgLy8gU2luY2Ugd2UgZGlkbid0IGZpbmQgaXQgc2l0dGluZyBpbiBhbiB1bmRpc2Nsb3NlZCBzaGFkb3cgKG9yIHNoYWRvd3MgYXJlIGRpc2FibGVkKVxyXG4gICAgLy8gIG5vdyB3ZSBjYW4ganVzdCB0ZXN0IHRvIHNlZSBpZiBpdCB3b3VsZCBub3JtYWxseSBiZSB2aXNpYmxlIG9yIG5vdCwgcHJvdmlkZWQgaXQnc1xyXG4gICAgLy8gIGF0dGFjaGVkIHRvIHRoZSBtYWluIGRvY3VtZW50LlxyXG4gICAgLy8gTk9URTogV2UgbXVzdCBjb25zaWRlciBjYXNlIHdoZXJlIG5vZGUgaXMgaW5zaWRlIGEgc2hhZG93IERPTSBhbmQgZ2l2ZW4gZGlyZWN0bHkgdG9cclxuICAgIC8vICBgaXNUYWJiYWJsZSgpYCBvciBgaXNGb2N1c2FibGUoKWAgLS0gcmVnYXJkbGVzcyBvZiBgZ2V0U2hhZG93Um9vdGAgb3B0aW9uIHNldHRpbmcuXHJcblxyXG4gICAgaWYgKGlzTm9kZUF0dGFjaGVkKG5vZGUpKSB7XHJcbiAgICAgIC8vIHRoaXMgd29ya3Mgd2hlcmV2ZXIgdGhlIG5vZGUgaXM6IGlmIHRoZXJlJ3MgYXQgbGVhc3Qgb25lIGNsaWVudCByZWN0LCBpdCdzXHJcbiAgICAgIC8vICBzb21laG93IGRpc3BsYXllZDsgaXQgYWxzbyBjb3ZlcnMgdGhlIENTUyAnZGlzcGxheTogY29udGVudHMnIGNhc2Ugd2hlcmUgdGhlXHJcbiAgICAgIC8vICBub2RlIGl0c2VsZiBpcyBoaWRkZW4gaW4gcGxhY2Ugb2YgaXRzIGNvbnRlbnRzOyBhbmQgdGhlcmUncyBubyBuZWVkIHRvIHNlYXJjaFxyXG4gICAgICAvLyAgdXAgdGhlIGhpZXJhcmNoeSBlaXRoZXJcclxuICAgICAgcmV0dXJuICFub2RlLmdldENsaWVudFJlY3RzKCkubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEVsc2UsIHRoZSBub2RlIGlzbid0IGF0dGFjaGVkIHRvIHRoZSBkb2N1bWVudCwgd2hpY2ggbWVhbnMgdGhlIGBnZXRDbGllbnRSZWN0cygpYFxyXG4gICAgLy8gIEFQSSB3aWxsIF9fYWx3YXlzX18gcmV0dXJuIHplcm8gcmVjdHMgKHRoaXMgY2FuIGhhcHBlbiwgZm9yIGV4YW1wbGUsIGlmIFJlYWN0XHJcbiAgICAvLyAgaXMgdXNlZCB0byByZW5kZXIgbm9kZXMgb250byBhIGRldGFjaGVkIHRyZWUsIGFzIGNvbmZpcm1lZCBpbiB0aGlzIHRocmVhZDpcclxuICAgIC8vICBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzkxMTcjaXNzdWVjb21tZW50LTI4NDIyODg3MClcclxuICAgIC8vXHJcbiAgICAvLyBJdCBhbHNvIG1lYW5zIHRoYXQgZXZlbiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS5kaXNwbGF5IHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgXHJcbiAgICAvLyAgYmVjYXVzZSBzdHlsZXMgYXJlIG9ubHkgY29tcHV0ZWQgZm9yIG5vZGVzIHRoYXQgYXJlIGluIHRoZSBkb2N1bWVudC5cclxuICAgIC8vXHJcbiAgICAvLyBOT1RFOiBUSElTIEhBUyBCRUVOIFRIRSBDQVNFIEZPUiBZRUFSUy4gSXQgaXMgbm90IG5ldywgbm9yIGlzIGl0IGNhdXNlZCBieSB0YWJiYWJsZVxyXG4gICAgLy8gIHNvbWVob3cuIFRob3VnaCBpdCB3YXMgbmV2ZXIgc3RhdGVkIG9mZmljaWFsbHksIGFueW9uZSB3aG8gaGFzIGV2ZXIgdXNlZCB0YWJiYWJsZVxyXG4gICAgLy8gIEFQSXMgb24gbm9kZXMgaW4gZGV0YWNoZWQgY29udGFpbmVycyBoYXMgYWN0dWFsbHkgaW1wbGljaXRseSB1c2VkIHRhYmJhYmxlIGluIHdoYXRcclxuICAgIC8vICB3YXMgbGF0ZXIgKGFzIG9mIHY1LjIuMCBvbiBBcHIgOSwgMjAyMSkgY2FsbGVkIGBkaXNwbGF5Q2hlY2s9XCJub25lXCJgIG1vZGUgLS0gZXNzZW50aWFsbHlcclxuICAgIC8vICBjb25zaWRlcmluZyBfX2V2ZXJ5dGhpbmdfXyB0byBiZSB2aXNpYmxlIGJlY2F1c2Ugb2YgdGhlIGlubmFiaWxpdHkgdG8gZGV0ZXJtaW5lIHN0eWxlcy5cclxuICAgIC8vXHJcbiAgICAvLyB2Ni4wLjA6IEFzIG9mIHRoaXMgbWFqb3IgcmVsZWFzZSwgdGhlIGRlZmF1bHQgJ2Z1bGwnIG9wdGlvbiBfX25vIGxvbmdlciB0cmVhdHMgZGV0YWNoZWRcclxuICAgIC8vICBub2RlcyBhcyB2aXNpYmxlIHdpdGggdGhlICdub25lJyBmYWxsYmFjay5fX1xyXG4gICAgaWYgKGRpc3BsYXlDaGVjayAhPT0gJ2xlZ2FjeS1mdWxsJykge1xyXG4gICAgICByZXR1cm4gdHJ1ZTsgLy8gaGlkZGVuXHJcbiAgICB9XHJcbiAgICAvLyBlbHNlLCBmYWxsYmFjayB0byAnbm9uZScgbW9kZSBhbmQgY29uc2lkZXIgdGhlIG5vZGUgdmlzaWJsZVxyXG4gIH0gZWxzZSBpZiAoZGlzcGxheUNoZWNrID09PSAnbm9uLXplcm8tYXJlYScpIHtcclxuICAgIC8vIE5PVEU6IEV2ZW4gdGhvdWdoIHRoaXMgdGVzdHMgdGhhdCB0aGUgbm9kZSdzIGNsaWVudCByZWN0IGlzIG5vbi16ZXJvIHRvIGRldGVybWluZVxyXG4gICAgLy8gIHdoZXRoZXIgaXQncyBkaXNwbGF5ZWQsIGFuZCB0aGF0IGEgZGV0YWNoZWQgbm9kZSB3aWxsIF9fYWx3YXlzX18gaGF2ZSBhIHplcm8tYXJlYVxyXG4gICAgLy8gIGNsaWVudCByZWN0LCB3ZSBkb24ndCBzcGVjaWFsLWNhc2UgZm9yIHdoZXRoZXIgdGhlIG5vZGUgaXMgYXR0YWNoZWQgb3Igbm90LiBJblxyXG4gICAgLy8gIHRoaXMgbW9kZSwgd2UgZG8gd2FudCB0byBjb25zaWRlciBub2RlcyB0aGF0IGhhdmUgYSB6ZXJvIGFyZWEgdG8gYmUgaGlkZGVuIGF0IGFsbFxyXG4gICAgLy8gIHRpbWVzLCBhbmQgdGhhdCBpbmNsdWRlcyBhdHRhY2hlZCBvciBub3QuXHJcbiAgICByZXR1cm4gaXNaZXJvQXJlYShub2RlKTtcclxuICB9XHJcblxyXG4gIC8vIHZpc2libGUsIGFzIGZhciBhcyB3ZSBjYW4gdGVsbCwgb3IgcGVyIGN1cnJlbnQgYGRpc3BsYXlDaGVjaz1ub25lYCBtb2RlLCB3ZSBhc3N1bWVcclxuICAvLyAgaXQncyB2aXNpYmxlXHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59O1xyXG5cclxuLy8gZm9ybSBmaWVsZHMgKG5lc3RlZCkgaW5zaWRlIGEgZGlzYWJsZWQgZmllbGRzZXQgYXJlIG5vdCBmb2N1c2FibGUvdGFiYmFibGVcclxuLy8gIHVubGVzcyB0aGV5IGFyZSBpbiB0aGUgX2ZpcnN0XyA8bGVnZW5kPiBlbGVtZW50IG9mIHRoZSB0b3AtbW9zdCBkaXNhYmxlZFxyXG4vLyAgZmllbGRzZXRcclxudmFyIGlzRGlzYWJsZWRGcm9tRmllbGRzZXQgPSBmdW5jdGlvbiBpc0Rpc2FibGVkRnJvbUZpZWxkc2V0KG5vZGUpIHtcclxuICBpZiAoL14oSU5QVVR8QlVUVE9OfFNFTEVDVHxURVhUQVJFQSkkLy50ZXN0KG5vZGUudGFnTmFtZSkpIHtcclxuICAgIHZhciBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnRFbGVtZW50O1xyXG4gICAgLy8gY2hlY2sgaWYgYG5vZGVgIGlzIGNvbnRhaW5lZCBpbiBhIGRpc2FibGVkIDxmaWVsZHNldD5cclxuICAgIHdoaWxlIChwYXJlbnROb2RlKSB7XHJcbiAgICAgIGlmIChwYXJlbnROb2RlLnRhZ05hbWUgPT09ICdGSUVMRFNFVCcgJiYgcGFyZW50Tm9kZS5kaXNhYmxlZCkge1xyXG4gICAgICAgIC8vIGxvb2sgZm9yIHRoZSBmaXJzdCA8bGVnZW5kPiBhbW9uZyB0aGUgY2hpbGRyZW4gb2YgdGhlIGRpc2FibGVkIDxmaWVsZHNldD5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudE5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIHZhciBjaGlsZCA9IHBhcmVudE5vZGUuY2hpbGRyZW4uaXRlbShpKTtcclxuICAgICAgICAgIC8vIHdoZW4gdGhlIGZpcnN0IDxsZWdlbmQ+IChpbiBkb2N1bWVudCBvcmRlcikgaXMgZm91bmRcclxuICAgICAgICAgIGlmIChjaGlsZC50YWdOYW1lID09PSAnTEVHRU5EJykge1xyXG4gICAgICAgICAgICAvLyBpZiBpdHMgcGFyZW50IDxmaWVsZHNldD4gaXMgbm90IG5lc3RlZCBpbiBhbm90aGVyIGRpc2FibGVkIDxmaWVsZHNldD4sXHJcbiAgICAgICAgICAgIC8vIHJldHVybiB3aGV0aGVyIGBub2RlYCBpcyBhIGRlc2NlbmRhbnQgb2YgaXRzIGZpcnN0IDxsZWdlbmQ+XHJcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVzLmNhbGwocGFyZW50Tm9kZSwgJ2ZpZWxkc2V0W2Rpc2FibGVkXSAqJykgPyB0cnVlIDogIWNoaWxkLmNvbnRhaW5zKG5vZGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0aGUgZGlzYWJsZWQgPGZpZWxkc2V0PiBjb250YWluaW5nIGBub2RlYCBoYXMgbm8gPGxlZ2VuZD5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICBwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnRFbGVtZW50O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gZWxzZSwgbm9kZSdzIHRhYmJhYmxlL2ZvY3VzYWJsZSBzdGF0ZSBzaG91bGQgbm90IGJlIGFmZmVjdGVkIGJ5IGEgZmllbGRzZXQnc1xyXG4gIC8vICBlbmFibGVkL2Rpc2FibGVkIHN0YXRlXHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59O1xyXG52YXIgaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZSA9IGZ1bmN0aW9uIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUob3B0aW9ucywgbm9kZSkge1xyXG4gIGlmIChub2RlLmRpc2FibGVkIHx8XHJcbiAgLy8gd2UgbXVzdCBkbyBhbiBpbmVydCBsb29rIHVwIHRvIGZpbHRlciBvdXQgYW55IGVsZW1lbnRzIGluc2lkZSBhbiBpbmVydCBhbmNlc3RvclxyXG4gIC8vICBiZWNhdXNlIHdlJ3JlIGxpbWl0ZWQgaW4gdGhlIHR5cGUgb2Ygc2VsZWN0b3JzIHdlIGNhbiB1c2UgaW4gSlNEb20gKHNlZSByZWxhdGVkXHJcbiAgLy8gIG5vdGUgcmVsYXRlZCB0byBgY2FuZGlkYXRlU2VsZWN0b3JzYClcclxuICBpc0luZXJ0KG5vZGUpIHx8IGlzSGlkZGVuSW5wdXQobm9kZSkgfHwgaXNIaWRkZW4obm9kZSwgb3B0aW9ucykgfHxcclxuICAvLyBGb3IgYSBkZXRhaWxzIGVsZW1lbnQgd2l0aCBhIHN1bW1hcnksIHRoZSBzdW1tYXJ5IGVsZW1lbnQgZ2V0cyB0aGUgZm9jdXNcclxuICBpc0RldGFpbHNXaXRoU3VtbWFyeShub2RlKSB8fCBpc0Rpc2FibGVkRnJvbUZpZWxkc2V0KG5vZGUpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHJldHVybiB0cnVlO1xyXG59O1xyXG52YXIgaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlID0gZnVuY3Rpb24gaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlKG9wdGlvbnMsIG5vZGUpIHtcclxuICBpZiAoaXNOb25UYWJiYWJsZVJhZGlvKG5vZGUpIHx8IGdldFRhYkluZGV4KG5vZGUpIDwgMCB8fCAhaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZShvcHRpb25zLCBub2RlKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICByZXR1cm4gdHJ1ZTtcclxufTtcclxudmFyIGlzVmFsaWRTaGFkb3dSb290VGFiYmFibGUgPSBmdW5jdGlvbiBpc1ZhbGlkU2hhZG93Um9vdFRhYmJhYmxlKHNoYWRvd0hvc3ROb2RlKSB7XHJcbiAgdmFyIHRhYkluZGV4ID0gcGFyc2VJbnQoc2hhZG93SG9zdE5vZGUuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpLCAxMCk7XHJcbiAgaWYgKGlzTmFOKHRhYkluZGV4KSB8fCB0YWJJbmRleCA+PSAwKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgLy8gSWYgYSBjdXN0b20gZWxlbWVudCBoYXMgYW4gZXhwbGljaXQgbmVnYXRpdmUgdGFiaW5kZXgsXHJcbiAgLy8gYnJvd3NlcnMgd2lsbCBub3QgYWxsb3cgdGFiIHRhcmdldGluZyBzYWlkIGVsZW1lbnQncyBjaGlsZHJlbi5cclxuICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtBcnJheS48RWxlbWVudHxDYW5kaWRhdGVTY29wZT59IGNhbmRpZGF0ZXNcclxuICogQHJldHVybnMgRWxlbWVudFtdXHJcbiAqL1xyXG52YXIgc29ydEJ5T3JkZXIgPSBmdW5jdGlvbiBzb3J0QnlPcmRlcihjYW5kaWRhdGVzKSB7XHJcbiAgdmFyIHJlZ3VsYXJUYWJiYWJsZXMgPSBbXTtcclxuICB2YXIgb3JkZXJlZFRhYmJhYmxlcyA9IFtdO1xyXG4gIGNhbmRpZGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaSkge1xyXG4gICAgdmFyIGlzU2NvcGUgPSAhIWl0ZW0uc2NvcGVQYXJlbnQ7XHJcbiAgICB2YXIgZWxlbWVudCA9IGlzU2NvcGUgPyBpdGVtLnNjb3BlUGFyZW50IDogaXRlbTtcclxuICAgIHZhciBjYW5kaWRhdGVUYWJpbmRleCA9IGdldFNvcnRPcmRlclRhYkluZGV4KGVsZW1lbnQsIGlzU2NvcGUpO1xyXG4gICAgdmFyIGVsZW1lbnRzID0gaXNTY29wZSA/IHNvcnRCeU9yZGVyKGl0ZW0uY2FuZGlkYXRlcykgOiBlbGVtZW50O1xyXG4gICAgaWYgKGNhbmRpZGF0ZVRhYmluZGV4ID09PSAwKSB7XHJcbiAgICAgIGlzU2NvcGUgPyByZWd1bGFyVGFiYmFibGVzLnB1c2guYXBwbHkocmVndWxhclRhYmJhYmxlcywgZWxlbWVudHMpIDogcmVndWxhclRhYmJhYmxlcy5wdXNoKGVsZW1lbnQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgb3JkZXJlZFRhYmJhYmxlcy5wdXNoKHtcclxuICAgICAgICBkb2N1bWVudE9yZGVyOiBpLFxyXG4gICAgICAgIHRhYkluZGV4OiBjYW5kaWRhdGVUYWJpbmRleCxcclxuICAgICAgICBpdGVtOiBpdGVtLFxyXG4gICAgICAgIGlzU2NvcGU6IGlzU2NvcGUsXHJcbiAgICAgICAgY29udGVudDogZWxlbWVudHNcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgcmV0dXJuIG9yZGVyZWRUYWJiYWJsZXMuc29ydChzb3J0T3JkZXJlZFRhYmJhYmxlcykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHNvcnRhYmxlKSB7XHJcbiAgICBzb3J0YWJsZS5pc1Njb3BlID8gYWNjLnB1c2guYXBwbHkoYWNjLCBzb3J0YWJsZS5jb250ZW50KSA6IGFjYy5wdXNoKHNvcnRhYmxlLmNvbnRlbnQpO1xyXG4gICAgcmV0dXJuIGFjYztcclxuICB9LCBbXSkuY29uY2F0KHJlZ3VsYXJUYWJiYWJsZXMpO1xyXG59O1xyXG52YXIgdGFiYmFibGUgPSBmdW5jdGlvbiB0YWJiYWJsZShjb250YWluZXIsIG9wdGlvbnMpIHtcclxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICB2YXIgY2FuZGlkYXRlcztcclxuICBpZiAob3B0aW9ucy5nZXRTaGFkb3dSb290KSB7XHJcbiAgICBjYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlc0l0ZXJhdGl2ZWx5KFtjb250YWluZXJdLCBvcHRpb25zLmluY2x1ZGVDb250YWluZXIsIHtcclxuICAgICAgZmlsdGVyOiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUuYmluZChudWxsLCBvcHRpb25zKSxcclxuICAgICAgZmxhdHRlbjogZmFsc2UsXHJcbiAgICAgIGdldFNoYWRvd1Jvb3Q6IG9wdGlvbnMuZ2V0U2hhZG93Um9vdCxcclxuICAgICAgc2hhZG93Um9vdEZpbHRlcjogaXNWYWxpZFNoYWRvd1Jvb3RUYWJiYWJsZVxyXG4gICAgfSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzKGNvbnRhaW5lciwgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLCBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUuYmluZChudWxsLCBvcHRpb25zKSk7XHJcbiAgfVxyXG4gIHJldHVybiBzb3J0QnlPcmRlcihjYW5kaWRhdGVzKTtcclxufTtcclxudmFyIGZvY3VzYWJsZSA9IGZ1bmN0aW9uIGZvY3VzYWJsZShjb250YWluZXIsIG9wdGlvbnMpIHtcclxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICB2YXIgY2FuZGlkYXRlcztcclxuICBpZiAob3B0aW9ucy5nZXRTaGFkb3dSb290KSB7XHJcbiAgICBjYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlc0l0ZXJhdGl2ZWx5KFtjb250YWluZXJdLCBvcHRpb25zLmluY2x1ZGVDb250YWluZXIsIHtcclxuICAgICAgZmlsdGVyOiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlLmJpbmQobnVsbCwgb3B0aW9ucyksXHJcbiAgICAgIGZsYXR0ZW46IHRydWUsXHJcbiAgICAgIGdldFNoYWRvd1Jvb3Q6IG9wdGlvbnMuZ2V0U2hhZG93Um9vdFxyXG4gICAgfSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzKGNvbnRhaW5lciwgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLCBpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlLmJpbmQobnVsbCwgb3B0aW9ucykpO1xyXG4gIH1cclxuICByZXR1cm4gY2FuZGlkYXRlcztcclxufTtcclxudmFyIGlzVGFiYmFibGUgPSBmdW5jdGlvbiBpc1RhYmJhYmxlKG5vZGUsIG9wdGlvbnMpIHtcclxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICBpZiAoIW5vZGUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignTm8gbm9kZSBwcm92aWRlZCcpO1xyXG4gIH1cclxuICBpZiAobWF0Y2hlcy5jYWxsKG5vZGUsIGNhbmRpZGF0ZVNlbGVjdG9yKSA9PT0gZmFsc2UpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgcmV0dXJuIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZShvcHRpb25zLCBub2RlKTtcclxufTtcclxudmFyIGZvY3VzYWJsZUNhbmRpZGF0ZVNlbGVjdG9yID0gLyogI19fUFVSRV9fICovY2FuZGlkYXRlU2VsZWN0b3JzLmNvbmNhdCgnaWZyYW1lJykuam9pbignLCcpO1xyXG52YXIgaXNGb2N1c2FibGUgPSBmdW5jdGlvbiBpc0ZvY3VzYWJsZShub2RlLCBvcHRpb25zKSB7XHJcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgaWYgKCFub2RlKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG5vZGUgcHJvdmlkZWQnKTtcclxuICB9XHJcbiAgaWYgKG1hdGNoZXMuY2FsbChub2RlLCBmb2N1c2FibGVDYW5kaWRhdGVTZWxlY3RvcikgPT09IGZhbHNlKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHJldHVybiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlKG9wdGlvbnMsIG5vZGUpO1xyXG59O1xyXG5cclxuZXhwb3J0IHsgZm9jdXNhYmxlLCBnZXRUYWJJbmRleCwgaXNGb2N1c2FibGUsIGlzVGFiYmFibGUsIHRhYmJhYmxlIH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbS5qcy5tYXBcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/tabbable/dist/index.esm.js\n");

/***/ })

};
;